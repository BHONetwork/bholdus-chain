<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A WebAssembly function which can be called."><meta name="keywords" content="rust, rustlang, rust-lang, Func"><title>wasmtime::Func - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../wasmtime/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Struct Func</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.call">call</a><a href="#method.call_async">call_async</a><a href="#method.new">new</a><a href="#method.new_async">new_async</a><a href="#method.param_arity">param_arity</a><a href="#method.result_arity">result_arity</a><a href="#method.store">store</a><a href="#method.ty">ty</a><a href="#method.typed">typed</a><a href="#method.typed_unchecked">typed_unchecked</a><a href="#method.wrap">wrap</a><a href="#method.wrap0_async">wrap0_async</a><a href="#method.wrap10_async">wrap10_async</a><a href="#method.wrap11_async">wrap11_async</a><a href="#method.wrap12_async">wrap12_async</a><a href="#method.wrap13_async">wrap13_async</a><a href="#method.wrap14_async">wrap14_async</a><a href="#method.wrap15_async">wrap15_async</a><a href="#method.wrap16_async">wrap16_async</a><a href="#method.wrap1_async">wrap1_async</a><a href="#method.wrap2_async">wrap2_async</a><a href="#method.wrap3_async">wrap3_async</a><a href="#method.wrap4_async">wrap4_async</a><a href="#method.wrap5_async">wrap5_async</a><a href="#method.wrap6_async">wrap6_async</a><a href="#method.wrap7_async">wrap7_async</a><a href="#method.wrap8_async">wrap8_async</a><a href="#method.wrap9_async">wrap9_async</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-From%3CFunc%3E">From&lt;Func&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><p class="location"><a href="index.html">wasmtime</a></p><div id="sidebar-vars" data-name="Func" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="index.html">wasmtime</a>::<wbr><a class="struct" href="">Func</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/wasmtime/func.rs.html#320-324" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct Func { /* fields omitted */ }</pre></div><div class="docblock"><p>A WebAssembly function which can be called.</p>
<p>This type can represent a number of callable items, such as:</p>
<ul>
<li>An exported function from a WebAssembly module.</li>
<li>A user-defined function used to satisfy an import.</li>
</ul>
<p>These types of callable items are all wrapped up in this <code>Func</code> and can be
used to both instantiate an <a href="../wasmtime/struct.Instance.html"><code>Instance</code></a> as well as be extracted from an
<a href="../wasmtime/struct.Instance.html"><code>Instance</code></a>.</p>
<h1 id="func-and-clone" class="section-header"><a href="#func-and-clone"><code>Func</code> and <code>Clone</code></a></h1>
<p>Functions are internally reference counted so you can <code>clone</code> a <code>Func</code>. The
cloning process only performs a shallow clone, so two cloned <code>Func</code>
instances are equivalent in their functionality.</p>
<h1 id="func-and-async" class="section-header"><a href="#func-and-async"><code>Func</code> and <code>async</code></a></h1>
<p>Functions from the perspective of WebAssembly are always synchronous. You
might have an <code>async</code> function in Rust, however, which you’d like to make
available from WebAssembly. Wasmtime supports asynchronously calling
WebAssembly through native stack switching. You can get some more
information about <a href="../wasmtime/struct.Config.html#method.async_support">asynchronous configs</a>, but from the
perspective of <code>Func</code> it’s important to know that whether or not your
<a href="../wasmtime/struct.Store.html" title="Store"><code>Store</code></a> is asynchronous will dictate whether you call functions through
<a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> or <a href="../wasmtime/struct.Func.html#method.call_async" title="Func::call_async"><code>Func::call_async</code></a> (or the typed wrappers such as
<a href="../wasmtime/struct.TypedFunc.html#method.call" title="TypedFunc::call"><code>TypedFunc::call</code></a> vs <a href="../wasmtime/struct.TypedFunc.html#method.call_async" title="TypedFunc::call_async"><code>TypedFunc::call_async</code></a>).</p>
<p>Note that asynchronous function APIs here are a bit trickier than their
synchronous brethren. For example <a href="../wasmtime/struct.Func.html#method.new_async" title="Func::new_async"><code>Func::new_async</code></a> and
<a href="../wasmtime/struct.Func.html#method.wrap1_async"><code>Func::wrapN_async</code></a> take explicit state parameters to
allow you to close over the state in the returned future. It’s recommended
that you pass state via these parameters instead of through the closure’s
environment, which may give Rust lifetime errors. Additionally unlike
synchronous functions which can all get wrapped through <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>
asynchronous functions need to explicitly wrap based on the number of
parameters that they have (e.g. no wasm parameters gives you
<a href="../wasmtime/struct.Func.html#method.wrap0_async" title="Func::wrap0_async"><code>Func::wrap0_async</code></a>, one wasm parameter you’d use <a href="../wasmtime/struct.Func.html#method.wrap1_async" title="Func::wrap1_async"><code>Func::wrap1_async</code></a>,
etc). Be sure to consult the documentation for <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a> for how the
wasm type signature is inferred from the Rust type signature.</p>
<h1 id="to-funccall-or-to-functypedcall" class="section-header"><a href="#to-funccall-or-to-functypedcall">To <code>Func::call</code> or to <code>Func::typed().call()</code></a></h1>
<p>There’s a 2x2 matrix of methods to call <code>Func</code>. Invocations can either be
asynchronous or synchronous. They can also be statically typed or not.
Whether or not an invocation is asynchronous is indicated via the method
being <code>async</code> and <code>call_async</code> being the entry point. Otherwise for
statically typed or not your options are:</p>
<ul>
<li>
<p>Dynamically typed - if you don’t statically know the signature of the
function that you’re calling you’ll be using <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> or
<a href="../wasmtime/struct.Func.html#method.call_async" title="Func::call_async"><code>Func::call_async</code></a>. These functions take a variable-length slice of
“boxed” arguments in their <a href="../wasmtime/enum.Val.html" title="Val"><code>Val</code></a> representation. Additionally the
results are returned as an owned slice of <a href="../wasmtime/enum.Val.html" title="Val"><code>Val</code></a>. These methods are not
optimized due to the dynamic type checks that must occur, in addition to
some dynamic allocations for where to put all the arguments. While this
allows you to call all possible wasm function signatures, if you’re
looking for a speedier alternative you can also use…</p>
</li>
<li>
<p>Statically typed - if you statically know the type signature of the wasm
function you’re calling, then you’ll want to use the <a href="../wasmtime/struct.Func.html#method.typed" title="Func::typed"><code>Func::typed</code></a>
method to acquire an instance of <a href="../wasmtime/struct.TypedFunc.html" title="TypedFunc"><code>TypedFunc</code></a>. This structure is static proof
that the underlying wasm function has the ascripted type, and type
validation is only done once up-front. The <a href="../wasmtime/struct.TypedFunc.html#method.call" title="TypedFunc::call"><code>TypedFunc::call</code></a> and
<a href="../wasmtime/struct.TypedFunc.html#method.call_async" title="TypedFunc::call_async"><code>TypedFunc::call_async</code></a> methods are much more efficient than <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a>
and <a href="../wasmtime/struct.Func.html#method.call_async" title="Func::call_async"><code>Func::call_async</code></a> because the type signature is statically known.
This eschews runtime checks as much as possible to get into wasm as fast
as possible.</p>
</li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>One way to get a <code>Func</code> is from an <a href="../wasmtime/struct.Instance.html"><code>Instance</code></a> after you’ve instantiated
it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine</span>::<span class="ident">default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">r#&quot;(module (func (export &quot;foo&quot;)))&quot;#</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_func</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;export wasn&#39;t a function&quot;</span>);

<span class="comment">// Work with `foo` as a `Func` at this point, such as calling it</span>
<span class="comment">// dynamically...</span>
<span class="kw">match</span> <span class="ident">foo</span>.<span class="ident">call</span>(<span class="kw-2">&amp;</span>[]) {
    <span class="prelude-val">Ok</span>(<span class="ident">result</span>) <span class="op">=</span><span class="op">&gt;</span> { <span class="comment">/* ... */</span> }
    <span class="prelude-val">Err</span>(<span class="ident">trap</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;execution of `foo` resulted in a wasm trap: {}&quot;</span>, <span class="ident">trap</span>);
    }
}
<span class="ident">foo</span>.<span class="ident">call</span>(<span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

<span class="comment">// ... or we can make a static assertion about its signature and call it.</span>
<span class="comment">// Our first call here can fail if the signatures don&#39;t match, and then the</span>
<span class="comment">// second call can fail if the function traps (like the `match` above).</span>
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">typed</span>::<span class="op">&lt;</span>(), ()<span class="op">&gt;</span>()<span class="question-mark">?</span>;
<span class="ident">foo</span>.<span class="ident">call</span>(())<span class="question-mark">?</span>;</pre></div>
<p>You can also use the <a href="../wasmtime/struct.Func.html#method.wrap"><code>wrap</code> function</a> to create a
<code>Func</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="ident">default</span>();

<span class="comment">// Create a custom `Func` which can execute arbitrary code inside of the</span>
<span class="comment">// closure.</span>
<span class="kw">let</span> <span class="ident">add</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">wrap</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="op">|</span><span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span><span class="op">|</span> <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> { <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span> });

<span class="comment">// Next we can hook that up to a wasm module which uses it.</span>
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $add (param i32 i32) (result i32)))
            (func (export &quot;call_add_twice&quot;) (result i32)
                i32.const 1
                i32.const 2
                call $add
                i32.const 3
                i32.const 4
                call $add
                i32.add))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">add</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">call_add_twice</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span><span class="op">&gt;</span>(<span class="string">&quot;call_add_twice&quot;</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">call_add_twice</span>.<span class="ident">call</span>(())<span class="question-mark">?</span>, <span class="number">10</span>);</pre></div>
<p>Or you could also create an entirely dynamic <code>Func</code>!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="ident">default</span>();

<span class="comment">// Here we need to define the type signature of our `Double` function and</span>
<span class="comment">// then wrap it up in a `Func`</span>
<span class="kw">let</span> <span class="ident">double_type</span> <span class="op">=</span> <span class="ident">wasmtime</span>::<span class="ident">FuncType</span>::<span class="ident">new</span>(
    [<span class="ident">wasmtime</span>::<span class="ident">ValType</span>::<span class="ident">I32</span>].<span class="ident">iter</span>().<span class="ident">cloned</span>(),
    [<span class="ident">wasmtime</span>::<span class="ident">ValType</span>::<span class="ident">I32</span>].<span class="ident">iter</span>().<span class="ident">cloned</span>(),
);
<span class="kw">let</span> <span class="ident">double</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="ident">double_type</span>, <span class="op">|</span><span class="kw">_</span>, <span class="ident">params</span>, <span class="ident">results</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">params</span>[<span class="number">0</span>].<span class="ident">unwrap_i32</span>();
    <span class="ident">value</span> <span class="kw-2">*</span><span class="op">=</span> <span class="number">2</span>;
    <span class="ident">results</span>[<span class="number">0</span>] <span class="op">=</span> <span class="ident">value</span>.<span class="ident">into</span>();
    <span class="prelude-val">Ok</span>(())
});

<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $double (param i32) (result i32)))
            (func $start
                i32.const 1
                call $double
                drop)
            (start $start))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">double</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="comment">// .. work with `instance` if necessary</span></pre></div>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/wasmtime/func.rs.html#385-1141" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;ty: <a class="struct" href="../wasmtime/struct.FuncType.html" title="struct wasmtime::FuncType">FuncType</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'_&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../wasmtime/struct.Trap.html" title="struct wasmtime::Trap">Trap</a>&gt; + 'static<br>) -&gt; Self</code><a class="srclink" href="../src/wasmtime/func.rs.html#409-445" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new <code>Func</code> with the given arguments, typically to create a
user-defined function to pass as an import to a module.</p>
<ul>
<li>
<p><code>store</code> - a cache of data where information is stored, typically
shared with a <a href="../wasmtime/struct.Module.html"><code>Module</code></a>.</p>
</li>
<li>
<p><code>ty</code> - the signature of this function, used to indicate what the
inputs and outputs are, which must be WebAssembly types.</p>
</li>
<li>
<p><code>func</code> - the native code invoked whenever this <code>Func</code> will be called.
This closure is provided a <a href="../wasmtime/struct.Caller.html" title="Caller"><code>Caller</code></a> as its first argument to learn
information about the caller, and then it’s passed a list of
parameters as a slice along with a mutable slice of where to write
results.</p>
</li>
</ul>
<p>Note that the implementation of <code>func</code> must adhere to the <code>ty</code>
signature given, error or traps may occur if it does not respect the
<code>ty</code> signature.</p>
<p>Additionally note that this is quite a dynamic function since signatures
are not statically known. For a more performant <code>Func</code> it’s recommended
to use <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a> if you can because with statically known
signatures the engine can optimize the implementation much more.</p>
</div><h4 id="method.new_async" class="method"><code>pub fn <a href="#method.new_async" class="fnname">new_async</a>&lt;T, F&gt;(store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, ty: <a class="struct" href="../wasmtime/struct.FuncType.html" title="struct wasmtime::FuncType">FuncType</a>, state: T, func: F) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../wasmtime/struct.Trap.html" title="struct wasmtime::Trap">Trap</a>&gt;&gt; + 'a&gt; + 'static,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#519-542" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new host-defined WebAssembly function which, when called,
will run the asynchronous computation defined by <code>func</code> to completion
and then return the result to WebAssembly.</p>
<p>This function is the asynchronous analogue of <a href="../wasmtime/struct.Func.html#method.new" title="Func::new"><code>Func::new</code></a> and much of
that documentation applies to this as well. There are a few key
differences (besides being asynchronous) that are worth pointing out:</p>
<ul>
<li>
<p>The state parameter <code>T</code> is passed to the provided function <code>F</code> on
each invocation. This is done so you can use the state in <code>T</code> in the
computation of the output future (the future can close over this
value). Unfortunately due to limitations of async-in-Rust right now
you <strong>cannot</strong> close over the captured variables in <code>F</code> itself in the
returned future. This means that you likely won’t close over much
state in <code>F</code> and will instead use <code>T</code>.</p>
</li>
<li>
<p>The closure here returns a <em>boxed</em> future, not something that simply
implements a future. This is also unfortunately due to limitations in
Rust right now.</p>
</li>
</ul>
<p>Overall we’re not super happy with this API signature and would love to
change it to make it more ergonomic. Despite this, however, you should
be able to still hook into asynchronous computations and plug them into
wasm. Improvements are always welcome with PRs!</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This function will panic if <code>store</code> is not associated with an <a href="../wasmtime/struct.Config.html#method.async_support">async
config</a>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Simulate some application-specific state as well as asynchronous</span>
<span class="comment">// functions to query that state.</span>
<span class="kw">struct</span> <span class="ident">MyDatabase</span> {
    <span class="comment">// ...</span>
}

<span class="kw">impl</span> <span class="ident">MyDatabase</span> {
    <span class="kw">async</span> <span class="kw">fn</span> <span class="ident">get_row_count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u32</span> {
        <span class="comment">// ...</span>
    }
}

<span class="kw">let</span> <span class="ident">my_database</span> <span class="op">=</span> <span class="ident">MyDatabase</span> {
    <span class="comment">// ...</span>
};

<span class="comment">// Using `new_async` we can hook up into calling our async</span>
<span class="comment">// `get_row_count` function.</span>
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">Engine</span>::<span class="ident">new</span>(<span class="ident">Config</span>::<span class="ident">new</span>().<span class="ident">async_support</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>);
<span class="kw">let</span> <span class="ident">get_row_count_type</span> <span class="op">=</span> <span class="ident">wasmtime</span>::<span class="ident">FuncType</span>::<span class="ident">new</span>(
    <span class="prelude-val">None</span>,
    <span class="prelude-val">Some</span>(<span class="ident">wasmtime</span>::<span class="ident">ValType</span>::<span class="ident">I32</span>),
);
<span class="kw">let</span> <span class="ident">double</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">new_async</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="ident">get_row_count_type</span>, <span class="ident">my_database</span>, <span class="op">|</span><span class="kw">_</span>, <span class="ident">database</span>, <span class="ident">params</span>, <span class="ident">results</span><span class="op">|</span> {
    <span class="ident">Box</span>::<span class="ident">new</span>(<span class="kw">async</span> <span class="kw">move</span> {
        <span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">database</span>.<span class="ident">get_row_count</span>().<span class="kw">await</span>;
        <span class="ident">results</span>[<span class="number">0</span>] <span class="op">=</span> <span class="ident">Val</span>::<span class="ident">I32</span>(<span class="ident">count</span> <span class="kw">as</span> <span class="ident">i32</span>);
        <span class="prelude-val">Ok</span>(())
    })
});
<span class="comment">// ...</span></pre></div>
</div><h4 id="method.wrap" class="method"><code>pub fn <a href="#method.wrap" class="fnname">wrap</a>&lt;Params, Results&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="../wasmtime/trait.IntoFunc.html" title="trait wasmtime::IntoFunc">IntoFunc</a>&lt;Params, Results&gt;<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#749-765" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates a new <code>Func</code> from the given Rust closure.</p>
<p>This function will create a new <code>Func</code> which, when called, will
execute the given Rust closure. Unlike <a href="../wasmtime/struct.Func.html#method.new" title="Func::new"><code>Func::new</code></a> the target
function being called is known statically so the type signature can
be inferred. Rust types will map to WebAssembly types as follows:</p>
<table><thead><tr><th>Rust Argument Type</th><th>WebAssembly Type</th></tr></thead><tbody>
<tr><td><code>i32</code></td><td><code>i32</code></td></tr>
<tr><td><code>u32</code></td><td><code>i32</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code></td></tr>
<tr><td><code>u64</code></td><td><code>i64</code></td></tr>
<tr><td><code>f32</code></td><td><code>f32</code></td></tr>
<tr><td><code>f64</code></td><td><code>f64</code></td></tr>
<tr><td>(not supported)</td><td><code>v128</code></td></tr>
<tr><td><code>Option&lt;Func&gt;</code></td><td><code>funcref</code></td></tr>
<tr><td><code>Option&lt;ExternRef&gt;</code></td><td><code>externref</code></td></tr>
</tbody></table>
<p>Any of the Rust types can be returned from the closure as well, in
addition to some extra types</p>
<table><thead><tr><th>Rust Return Type</th><th>WebAssembly Return Type</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>nothing</td><td>no return value</td></tr>
<tr><td><code>T</code></td><td><code>T</code></td><td>a single return value</td></tr>
<tr><td><code>(T1, T2, ...)</code></td><td><code>T1 T2 ...</code></td><td>multiple returns</td></tr>
</tbody></table>
<p>Note that all return types can also be wrapped in <code>Result&lt;_, Trap&gt;</code> to
indicate that the host function can generate a trap as well as possibly
returning a value.</p>
<p>Finally you can also optionally take <a href="../wasmtime/struct.Caller.html" title="Caller"><code>Caller</code></a> as the first argument of
your closure. If inserted then you’re able to inspect the caller’s
state, for example the <a href="../wasmtime/struct.Memory.html"><code>Memory</code></a> it has exported so you
can read what pointers point to.</p>
<p>Note that when using this API, the intention is to create as thin of a
layer as possible for when WebAssembly calls the function provided. With
sufficient inlining and optimization the WebAssembly will call straight
into <code>func</code> provided, with no extra fluff entailed.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>First up we can see how simple wasm imports can be implemented, such
as a function that adds its two arguments and returns the result.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">add</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">wrap</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="op">|</span><span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span><span class="op">|</span> <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $add (param i32 i32) (result i32)))
            (func (export &quot;foo&quot;) (param i32 i32) (result i32)
                local.get 0
                local.get 1
                call $add))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">add</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), <span class="ident">i32</span><span class="op">&gt;</span>(<span class="string">&quot;foo&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">foo</span>.<span class="ident">call</span>((<span class="number">1</span>, <span class="number">2</span>))<span class="question-mark">?</span>, <span class="number">3</span>);</pre></div>
<p>We can also do the same thing, but generate a trap if the addition
overflows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">add</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">wrap</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="op">|</span><span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span><span class="op">|</span> {
    <span class="kw">match</span> <span class="ident">a</span>.<span class="ident">checked_add</span>(<span class="ident">b</span>) {
        <span class="prelude-val">Some</span>(<span class="ident">i</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(<span class="ident">i</span>),
        <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">Trap</span>::<span class="ident">new</span>(<span class="string">&quot;overflow&quot;</span>)),
    }
});
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $add (param i32 i32) (result i32)))
            (func (export &quot;foo&quot;) (param i32 i32) (result i32)
                local.get 0
                local.get 1
                call $add))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">add</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), <span class="ident">i32</span><span class="op">&gt;</span>(<span class="string">&quot;foo&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">foo</span>.<span class="ident">call</span>((<span class="number">1</span>, <span class="number">2</span>))<span class="question-mark">?</span>, <span class="number">3</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">foo</span>.<span class="ident">call</span>((<span class="ident">i32</span>::<span class="ident">max_value</span>(), <span class="number">1</span>)).<span class="ident">is_err</span>());</pre></div>
<p>And don’t forget all the wasm types are supported!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">debug</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">wrap</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="op">|</span><span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">u32</span>, <span class="ident">c</span>: <span class="ident">f32</span>, <span class="ident">d</span>: <span class="ident">i64</span>, <span class="ident">e</span>: <span class="ident">u64</span>, <span class="ident">f</span>: <span class="ident">f64</span><span class="op">|</span> {

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;a={}&quot;</span>, <span class="ident">a</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;b={}&quot;</span>, <span class="ident">b</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;c={}&quot;</span>, <span class="ident">c</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;d={}&quot;</span>, <span class="ident">d</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;e={}&quot;</span>, <span class="ident">e</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;f={}&quot;</span>, <span class="ident">f</span>);
});
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $debug (param i32 i32 f32 i64 i64 f64)))
            (func (export &quot;foo&quot;)
                i32.const -1
                i32.const 1
                f32.const 2
                i64.const -3
                i64.const 3
                f64.const 4
                call $debug))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">debug</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), ()<span class="op">&gt;</span>(<span class="string">&quot;foo&quot;</span>)<span class="question-mark">?</span>;
<span class="ident">foo</span>.<span class="ident">call</span>(())<span class="question-mark">?</span>;</pre></div>
<p>Finally if you want to get really fancy you can also implement
imports that read/write wasm module’s memory</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>;

<span class="kw">let</span> <span class="ident">log_str</span> <span class="op">=</span> <span class="ident">Func</span>::<span class="ident">wrap</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="op">|</span><span class="ident">caller</span>: <span class="ident">Caller</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>, <span class="ident">ptr</span>: <span class="ident">i32</span>, <span class="ident">len</span>: <span class="ident">i32</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="ident">mem</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">caller</span>.<span class="ident">get_export</span>(<span class="string">&quot;memory&quot;</span>) {
        <span class="prelude-val">Some</span>(<span class="ident">Extern</span>::<span class="ident">Memory</span>(<span class="ident">mem</span>)) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">mem</span>,
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Trap</span>::<span class="ident">new</span>(<span class="string">&quot;failed to find host memory&quot;</span>)),
    };

    <span class="comment">// We&#39;re reading raw wasm memory here so we need `unsafe`. Note</span>
    <span class="comment">// though that this should be safe because we don&#39;t reenter wasm</span>
    <span class="comment">// while we&#39;re reading wasm memory, nor should we clash with</span>
    <span class="comment">// any other memory accessors (assuming they&#39;re well-behaved</span>
    <span class="comment">// too).</span>
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">mem</span>.<span class="ident">data_unchecked</span>()
            .<span class="ident">get</span>(<span class="ident">ptr</span> <span class="kw">as</span> <span class="ident">u32</span> <span class="kw">as</span> <span class="ident">usize</span>..)
            .<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">arr</span><span class="op">|</span> <span class="ident">arr</span>.<span class="ident">get</span>(..<span class="ident">len</span> <span class="kw">as</span> <span class="ident">u32</span> <span class="kw">as</span> <span class="ident">usize</span>));
        <span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">data</span> {
            <span class="prelude-val">Some</span>(<span class="ident">data</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">match</span> <span class="ident">str</span>::<span class="ident">from_utf8</span>(<span class="ident">data</span>) {
                <span class="prelude-val">Ok</span>(<span class="ident">s</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">s</span>,
                <span class="prelude-val">Err</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Trap</span>::<span class="ident">new</span>(<span class="string">&quot;invalid utf-8&quot;</span>)),
            },
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Trap</span>::<span class="ident">new</span>(<span class="string">&quot;pointer/length out of bounds&quot;</span>)),
        };
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">string</span>, <span class="string">&quot;Hello, world!&quot;</span>);
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">string</span>);
    }
    <span class="prelude-val">Ok</span>(())
});
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(
    <span class="ident">store</span>.<span class="ident">engine</span>(),
    <span class="string">r#&quot;
        (module
            (import &quot;&quot; &quot;&quot; (func $log_str (param i32 i32)))
            (func (export &quot;foo&quot;)
                i32.const 4   ;; ptr
                i32.const 13  ;; len
                call $log_str)
            (memory (export &quot;memory&quot;) 1)
            (data (i32.const 4) &quot;Hello, world!&quot;))
    &quot;#</span>,
)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">log_str</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), ()<span class="op">&gt;</span>(<span class="string">&quot;foo&quot;</span>)<span class="question-mark">?</span>;
<span class="ident">foo</span>.<span class="ident">call</span>(())<span class="question-mark">?</span>;</pre></div>
</div><h4 id="method.wrap0_async" class="method"><code>pub fn <a href="#method.wrap0_async" class="fnname">wrap0_async</a>&lt;T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap1_async" class="method"><code>pub fn <a href="#method.wrap1_async" class="fnname">wrap1_async</a>&lt;T, A1, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap2_async" class="method"><code>pub fn <a href="#method.wrap2_async" class="fnname">wrap2_async</a>&lt;T, A1, A2, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap3_async" class="method"><code>pub fn <a href="#method.wrap3_async" class="fnname">wrap3_async</a>&lt;T, A1, A2, A3, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap4_async" class="method"><code>pub fn <a href="#method.wrap4_async" class="fnname">wrap4_async</a>&lt;T, A1, A2, A3, A4, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap5_async" class="method"><code>pub fn <a href="#method.wrap5_async" class="fnname">wrap5_async</a>&lt;T, A1, A2, A3, A4, A5, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap6_async" class="method"><code>pub fn <a href="#method.wrap6_async" class="fnname">wrap6_async</a>&lt;T, A1, A2, A3, A4, A5, A6, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap7_async" class="method"><code>pub fn <a href="#method.wrap7_async" class="fnname">wrap7_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap8_async" class="method"><code>pub fn <a href="#method.wrap8_async" class="fnname">wrap8_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap9_async" class="method"><code>pub fn <a href="#method.wrap9_async" class="fnname">wrap9_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap10_async" class="method"><code>pub fn <a href="#method.wrap10_async" class="fnname">wrap10_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap11_async" class="method"><code>pub fn <a href="#method.wrap11_async" class="fnname">wrap11_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap12_async" class="method"><code>pub fn <a href="#method.wrap12_async" class="fnname">wrap12_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A12: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-13" class="section-header"><a href="#panics-13">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap13_async" class="method"><code>pub fn <a href="#method.wrap13_async" class="fnname">wrap13_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A12: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A13: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-14" class="section-header"><a href="#panics-14">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap14_async" class="method"><code>pub fn <a href="#method.wrap14_async" class="fnname">wrap14_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A12: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A13: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A14: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-15" class="section-header"><a href="#panics-15">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap15_async" class="method"><code>pub fn <a href="#method.wrap15_async" class="fnname">wrap15_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A12: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A13: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A14: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A15: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-16" class="section-header"><a href="#panics-16">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.wrap16_async" class="method"><code>pub fn <a href="#method.wrap16_async" class="fnname">wrap16_async</a>&lt;T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;state: T, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../wasmtime/struct.Caller.html" title="struct wasmtime::Caller">Caller</a>&lt;'a&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = R&gt; + 'a&gt; + 'static<br>) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;A1: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A2: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A3: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A4: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A5: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A6: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A7: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A8: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A9: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A10: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A11: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A12: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A13: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A14: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A15: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A16: <a class="trait" href="../wasmtime/trait.WasmTy.html" title="trait wasmtime::WasmTy">WasmTy</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../wasmtime/trait.WasmRet.html" title="trait wasmtime::WasmRet">WasmRet</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#767" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>, except the closure asynchronously produces
its result. For more information see the <a href="../wasmtime/struct.Func.html" title="Func"><code>Func</code></a> documentation.</p>
<h1 id="panics-17" class="section-header"><a href="#panics-17">Panics</a></h1>
<p>This function will panic if called with a non-asynchronous store.</p>
</div><h4 id="method.ty" class="method"><code>pub fn <a href="#method.ty" class="fnname">ty</a>(&amp;self) -&gt; <a class="struct" href="../wasmtime/struct.FuncType.html" title="struct wasmtime::FuncType">FuncType</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#774-785" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the underlying wasm type that this <code>Func</code> has.</p>
</div><h4 id="method.param_arity" class="method"><code>pub fn <a href="#method.param_arity" class="fnname">param_arity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#788-790" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of parameters that this function takes.</p>
</div><h4 id="method.result_arity" class="method"><code>pub fn <a href="#method.result_arity" class="fnname">result_arity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#793-795" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of results this function produces.</p>
</div><h4 id="method.call" class="method"><code>pub fn <a href="#method.call" class="fnname">call</a>(&amp;self, params: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;</code><a class="srclink" href="../src/wasmtime/func.rs.html#809-815" title="goto source code">[src]</a></h4><div class="docblock"><p>Invokes this function with the <code>params</code> given, returning the results and
any trap, if one occurs.</p>
<p>The <code>params</code> here must match the type signature of this <code>Func</code>, or a
trap will occur. If a trap occurs while executing this function, then a
trap will also be returned.</p>
<h1 id="panics-18" class="section-header"><a href="#panics-18">Panics</a></h1>
<p>This function will panic if called on a function belonging to an async
store. Asynchronous stores must always use <code>call_async</code>.
initiates a panic.</p>
</div><h4 id="method.call_async" class="method"><code>pub async fn <a href="#method.call_async" class="fnname">call_async</a>(&amp;self, params: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt;</code><a class="srclink" href="../src/wasmtime/func.rs.html#840-847" title="goto source code">[src]</a></h4><div class="docblock"><p>Invokes this function with the <code>params</code> given, returning the results
asynchronously.</p>
<p>This function is the same as <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> except that it is
asynchronous. This is only compatible with stores associated with an
<a href="../wasmtime/struct.Config.html#method.async_support">asynchronous config</a>.</p>
<p>It’s important to note that the execution of WebAssembly will happen
synchronously in the <code>poll</code> method of the future returned from this
function. Wasmtime does not manage its own thread pool or similar to
execute WebAssembly in. Future <code>poll</code> methods are generally expected to
resolve quickly, so it’s recommended that you run or poll this future
in a “blocking context”.</p>
<p>For more information see the documentation on <a href="../wasmtime/struct.Config.html#method.async_support">asynchronous
configs</a>.</p>
<h1 id="panics-19" class="section-header"><a href="#panics-19">Panics</a></h1>
<p>Panics if this is called on a function in a synchronous store. This
only works with functions defined within an asynchronous store.</p>
</div><h4 id="method.store" class="method"><code>pub fn <a href="#method.store" class="fnname">store</a>(&amp;self) -&gt; &amp;<a class="struct" href="../wasmtime/struct.Store.html" title="struct wasmtime::Store">Store</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#925-927" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a reference to this function’s store.</p>
</div><h4 id="method.typed" class="method"><code>pub fn <a href="#method.typed" class="fnname">typed</a>&lt;Params, Results&gt;(&amp;self) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;&amp;<a class="struct" href="../wasmtime/struct.TypedFunc.html" title="struct wasmtime::TypedFunc">TypedFunc</a>&lt;Params, Results&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Params: <a class="trait" href="../wasmtime/trait.WasmParams.html" title="trait wasmtime::WasmParams">WasmParams</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Results: <a class="trait" href="../wasmtime/trait.WasmResults.html" title="trait wasmtime::WasmResults">WasmResults</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#1103-1116" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempts to extract a typed object from this <code>Func</code> through which the
function can be called.</p>
<p>This function serves as an alternative to <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> and
<a href="../wasmtime/struct.Func.html#method.call_async" title="Func::call_async"><code>Func::call_async</code></a>. This method performs a static type check (using
the <code>Params</code> and <code>Results</code> type parameters on the underlying wasm
function. If the type check passes then a <code>TypedFunc</code> object is returned,
otherwise an error is returned describing the typecheck failure.</p>
<p>The purpose of this relative to <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> is that it’s much more
efficient when used to invoke WebAssembly functions. With the types
statically known far less setup/teardown is required when invoking
WebAssembly. If speed is desired then this function is recommended to be
used instead of <a href="../wasmtime/struct.Func.html#method.call" title="Func::call"><code>Func::call</code></a> (which is more general, hence its
slowdown).</p>
<p>The <code>Params</code> type parameter is used to describe the parameters of the
WebAssembly function. This can either be a single type (like <code>i32</code>), or
a tuple of types representing the list of parameters (like <code>(i32, f32, f64)</code>). Additionally you can use <code>()</code> to represent that the function has
no parameters.</p>
<p>The <code>Results</code> type parameter is used to describe the results of the
function. This behaves the same way as <code>Params</code>, but just for the
results of the function.</p>
<p>Translation between Rust types and WebAssembly types looks like:</p>
<table><thead><tr><th>WebAssembly</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>i32</code></td><td><code>i32</code> or <code>u32</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code> or <code>u64</code></td></tr>
<tr><td><code>f32</code></td><td><code>f32</code></td></tr>
<tr><td><code>f64</code></td><td><code>f64</code></td></tr>
<tr><td><code>externref</code></td><td><code>Option&lt;ExternRef&gt;</code></td></tr>
<tr><td><code>funcref</code></td><td><code>Option&lt;Func&gt;</code></td></tr>
<tr><td><code>v128</code></td><td>not supported</td></tr>
</tbody></table>
<p>(note that this mapping is the same as that of <a href="../wasmtime/struct.Func.html#method.wrap" title="Func::wrap"><code>Func::wrap</code></a>).</p>
<p>Note that once the <a href="../wasmtime/struct.TypedFunc.html" title="TypedFunc"><code>TypedFunc</code></a> return value is acquired you’ll use either
<a href="../wasmtime/struct.TypedFunc.html#method.call" title="TypedFunc::call"><code>TypedFunc::call</code></a> or <a href="../wasmtime/struct.TypedFunc.html#method.call_async" title="TypedFunc::call_async"><code>TypedFunc::call_async</code></a> as necessary to actually invoke
the function. This method does not invoke any WebAssembly code, it
simply performs a typecheck before returning the <a href="../wasmtime/struct.TypedFunc.html" title="TypedFunc"><code>TypedFunc</code></a> value.</p>
<p>This method also has a convenience wrapper as
<a href="../wasmtime/struct.Instance.html#method.get_typed_func"><code>Instance::get_typed_func</code></a> to
directly get a typed function value from an
<a href="../wasmtime/struct.Instance.html"><code>Instance</code></a>.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>This function will return an error if <code>Params</code> or <code>Results</code> does not
match the native type of this WebAssembly function.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>An end-to-end example of calling a function which takes no parameters
and has no results:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine</span>::<span class="ident">default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">r#&quot;(module (func (export &quot;foo&quot;)))&quot;#</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_func</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;export wasn&#39;t a function&quot;</span>);

<span class="comment">// Note that this call can fail due to the typecheck not passing, but</span>
<span class="comment">// in our case we statically know the module so we know this should</span>
<span class="comment">// pass.</span>
<span class="kw">let</span> <span class="ident">typed</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">typed</span>::<span class="op">&lt;</span>(), ()<span class="op">&gt;</span>()<span class="question-mark">?</span>;

<span class="comment">// Note that this can fail if the wasm traps at runtime.</span>
<span class="ident">typed</span>.<span class="ident">call</span>(())<span class="question-mark">?</span>;</pre></div>
<p>You can also pass in multiple parameters and get a result back</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">typed</span> <span class="op">=</span> <span class="ident">add</span>.<span class="ident">typed</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i64</span>), <span class="ident">f32</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">typed</span>.<span class="ident">call</span>((<span class="number">1</span>, <span class="number">2</span>))<span class="question-mark">?</span>, <span class="number">3.0</span>);</pre></div>
<p>and similarly if a function has multiple results you can bind that too</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">typed</span> <span class="op">=</span> <span class="ident">add_with_overflow</span>.<span class="ident">typed</span>::<span class="op">&lt;</span>(<span class="ident">u32</span>, <span class="ident">u32</span>), (<span class="ident">u32</span>, <span class="ident">i32</span>)<span class="op">&gt;</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="ident">result</span>, <span class="ident">overflow</span>) <span class="op">=</span> <span class="ident">typed</span>.<span class="ident">call</span>((<span class="ident">u32</span>::<span class="ident">max_value</span>(), <span class="number">2</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">overflow</span>, <span class="number">1</span>);</pre></div>
</div><h4 id="method.typed_unchecked" class="method"><code>pub unsafe fn <a href="#method.typed_unchecked" class="fnname">typed_unchecked</a>&lt;Params, Results&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self<br>) -&gt; &amp;<a class="struct" href="../wasmtime/struct.TypedFunc.html" title="struct wasmtime::TypedFunc">TypedFunc</a>&lt;Params, Results&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Params: <a class="trait" href="../wasmtime/trait.WasmParams.html" title="trait wasmtime::WasmParams">WasmParams</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Results: <a class="trait" href="../wasmtime/trait.WasmResults.html" title="trait wasmtime::WasmResults">WasmResults</a>,&nbsp;</span></code><a class="srclink" href="../src/wasmtime/func.rs.html#1130-1140" title="goto source code">[src]</a></h4><div class="docblock"><p>An unchecked version of <a href="../wasmtime/struct.Func.html#method.typed" title="Func::typed"><code>Func::typed</code></a> which does not perform a
typecheck and simply assumes that the type declared here matches the
type of this function.</p>
<p>The semantics of this function are the same as <a href="../wasmtime/struct.Func.html#method.typed" title="Func::typed"><code>Func::typed</code></a> except
that no error is returned because no typechecking is done.</p>
<h1 id="unsafety" class="section-header"><a href="#unsafety">Unsafety</a></h1>
<p>This function only safe to call if <code>typed</code> would otherwise return <code>Ok</code>
for the same <code>Params</code> and <code>Results</code> specified. If <code>typed</code> would return
an error then the returned <code>TypedFunc</code> is memory unsafe to invoke.</p>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Clone" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/wasmtime/func.rs.html#319" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#319" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../src/wasmtime/func.rs.html#1143-1147" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/wasmtime/func.rs.html#1144-1146" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-From%3CFunc%3E" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a>&gt; for <a class="enum" href="../wasmtime/enum.Extern.html" title="enum wasmtime::Extern">Extern</a></code><a href="#impl-From%3CFunc%3E" class="anchor"></a><a class="srclink" href="../src/wasmtime/externals.rs.html#176-180" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(r: <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a>) -&gt; Self</code><a class="srclink" href="../src/wasmtime/externals.rs.html#177-179" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3CFunc%3E-1" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a>&gt; for <a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a></code><a href="#impl-From%3CFunc%3E-1" class="anchor"></a><a class="srclink" href="../src/wasmtime/values.rs.html#249-253" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(val: <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a>) -&gt; <a class="enum" href="../wasmtime/enum.Val.html" title="enum wasmtime::Val">Val</a></code><a class="srclink" href="../src/wasmtime/values.rs.html#250-252" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-RefUnwindSafe" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-Send" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-Sync" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-Unpin" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../wasmtime/struct.Func.html" title="struct wasmtime::Func">Func</a></code><a href="#impl-UnwindSafe" class="anchor"></a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-2" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Pointable" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</code><a href="#impl-Pointable" class="anchor"></a><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#194-214" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedconstant.ALIGN" class="associatedconstant hidden"><code>pub const <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant"><b>ALIGN</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#195" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>The alignment of pointer.</p>
</div><h4 id="associatedtype.Init" class="type"><code>type <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="type">Init</a> = T</code></h4><div class='docblock'><p>The type for initializers.</p>
</div><h4 id="method.init" class="method hidden"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fnname">init</a>(init: &lt;T as <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="type" href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#199" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Initializes a with the given initializer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></p>
</div><h4 id="method.deref" class="method hidden"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</code><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#203" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></p>
</div><h4 id="method.deref_mut" class="method hidden"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</code><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#207" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></p>
</div><h4 id="method.drop" class="method hidden"><code>pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#211" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Drops the object pointed to by the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></p>
</div></div><h3 id="impl-Same%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a>&lt;T&gt; for T</code><a href="#impl-Same%3CT%3E" class="anchor"></a><a class="srclink" href="../src/typenum/type_operators.rs.html#34-36" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output" class="type"><code>type <a href="../typenum/type_operators/trait.Same.html#associatedtype.Output" class="type">Output</a> = T</code></h4><div class='docblock'><p>Should always be <code>Self</code></p>
</div></div><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-93" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Owned" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#90" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-VZip%3CV%3E" class="impl"><code class="in-band">impl&lt;V, T&gt; <a class="trait" href="../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-VZip%3CV%3E" class="anchor"></a><a class="srclink" href="../src/ppv_lite86/types.rs.html#211-219" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.vzip" class="method hidden"><code>pub fn <a href="../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fnname">vzip</a>(self) -&gt; V</code><a class="srclink" href="../src/ppv_lite86/types.rs.html#216" title="goto source code">[src]</a></h4></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="wasmtime" data-search-js="../search-index.js"></div>
    <script src="../main.js"></script></body></html>